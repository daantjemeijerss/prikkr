name: Auto-refresh ACTIVE Prikkrs

on:
  schedule:
    - cron: "0 * * * *"   # every hour (UTC)
  workflow_dispatch:

jobs:
  ping:
    runs-on: ubuntu-latest
    env:
      BASE_URL: ${{ vars.BASE_URL }}
      CRON_SECRET: ${{ secrets.CRON_SECRET }}
      KV_REST_API_URL: ${{ secrets.KV_REST_API_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN }}
      # --- tuning knobs ---
      ACTIVE_DAYS: "7"                          # active if touched within N days
      ACTIVE_STATUSES: "collecting,open,active" # comma-separated allowed statuses
    steps:
      - name: Discover ACTIVE meta:* keys via KV REST and call refresh (with jitter)
        shell: bash
        run: |
          set -euo pipefail

          # rand_sleep MIN_MS MAX_MS  (default 100..500)
          rand_sleep() {
            local min_ms="${1:-100}"
            local max_ms="${2:-500}"
            local span=$(( max_ms - min_ms ))
            local r=$(( RANDOM % (span + 1) + min_ms ))   # milliseconds
            # convert ms -> seconds with 3 decimals; GNU sleep accepts decimals
            local secs
            secs=$(awk -v r="$r" 'BEGIN{printf "%.3f", r/1000}')
            sleep "$secs"
          }

          # -------- initial jitter so all repos don't thundering-herd at :00 --------
          initial=$(( RANDOM % 31 + 5 ))  # 5..35 seconds
          echo "Initial jitter: sleeping ${initial}s..."
          sleep "${initial}s"

          cursor=0
          keys=()

          # -------- SCAN: find all meta:* keys (supports Vercel KV + Upstash) --------
          while : ; do
            if [[ "$KV_REST_API_URL" == *"upstash.io"* ]]; then
              # Upstash shape
              RESP=$(curl -fsS \
                -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                "$KV_REST_API_URL/scan/${cursor}?match=meta:*&count=200")
              new_cursor=$(echo "$RESP" | jq -r '.result[0]')
              page_keys=$(echo "$RESP" | jq -r '.result[1][]?' || true)
            else
              # Vercel KV shape
              RESP=$(curl -fsS \
                -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                "$KV_REST_API_URL/scan?cursor=${cursor}&match=meta:*&count=200")
              new_cursor=$(echo "$RESP" | jq -r '.cursor // .Cursor // "0"')
              page_keys=$(echo "$RESP" | jq -r '.keys[]?' || true)
            fi

            while IFS= read -r k; do
              [[ -n "$k" ]] && keys+=("$k")
            done <<< "$page_keys"

            [[ -z "$new_cursor" || "$new_cursor" == "0" || "$new_cursor" == "null" ]] && break
            cursor="$new_cursor"
          done

          echo "Found ${#keys[@]} meta:* keys"

          # -------- helper: fetch meta JSON by key (handles both REST shapes) --------
          get_meta_json() {
            local key="$1"
            local RESP
            if [[ "$KV_REST_API_URL" == *"upstash.io"* ]]; then
              RESP=$(curl -fsS -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                "$KV_REST_API_URL/get/${key}")
              echo "$RESP" | jq -r '.result' 2>/dev/null
            else
              if RESP=$(curl -fsS -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                    "$KV_REST_API_URL/get/${key}" 2>/dev/null); then
                :
              else
                RESP=$(curl -fsS -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                    "$KV_REST_API_URL/get?key=${key}")
              fi
              echo "$RESP" | jq -r '.result // .value' 2>/dev/null
            fi
          }

          # -------- filter: keep only ACTIVE prikkrs --------
          active_ids=()
          now_epoch=$(date -u +%s)
          limit_secs=$(( ${ACTIVE_DAYS} * 86400 ))
          allowed_statuses_regex=$(echo "$ACTIVE_STATUSES" | sed 's/,/|/g')

          for key in "${keys[@]}"; do
            meta_raw=$(get_meta_json "$key" || true)
            [[ -z "$meta_raw" || "$meta_raw" == "null" ]] && continue

            # meta may be stored as a JSON string or as an object; normalize to object
            meta_json=$(echo "$meta_raw" | jq -r 'try (type=="string") as $s | (if $s then fromjson else . end) catch empty')
            [[ -z "$meta_json" ]] && meta_json="$meta_raw"

            status=$(echo "$meta_json" | jq -r '.status // .phase // empty')
            lastTouched=$(echo "$meta_json" | jq -r '.lastViewedAt // .updatedAt // .createdAt // empty')
            rangeTo=$(echo "$meta_json" | jq -r '.range.to // empty')

            # status filter
            if [[ -n "$status" ]]; then
              if ! echo "$status" | grep -Eiq "^(${allowed_statuses_regex})$"; then
                continue
              fi
            fi

            # recency filter
            keep_recent=1
            if [[ -n "$lastTouched" ]]; then
              if ts_epoch=$(date -u -d "$lastTouched" +%s 2>/dev/null); then
                age=$(( now_epoch - ts_epoch ))
                (( age <= limit_secs )) || keep_recent=0
              fi
            fi
            (( keep_recent == 1 )) || continue

            # optional: skip very old ranges (>30d past)
            if [[ -n "$rangeTo" ]]; then
              if to_epoch=$(date -u -d "$rangeTo" +%s 2>/dev/null); then
                (( now_epoch - to_epoch <= 30*86400 )) || continue
              fi
            fi

            active_ids+=("${key#meta:}")
          done

          if [[ ${#active_ids[@]} -eq 0 ]]; then
            echo "No ACTIVE Prikkrs. Exiting."
            exit 0
          fi

          echo "Active IDs before shuffle: ${#active_ids[@]}"
          mapfile -t active_ids < <(printf "%s\n" "${active_ids[@]}" | shuf)
          echo "Active IDs after shuffle: ${#active_ids[@]}"

          for id in "${active_ids[@]}"; do
            url="$BASE_URL/api/cron/refresh/$CRON_SECRET?id=$id"
            echo "GET $url"
            curl -fsS "$url" >/dev/null && echo " ok" || echo " (failed)"
            # small random delay 120â€“420ms
            rand_sleep 120 420
          done
