name: Auto-refresh ACTIVE Prikkrs

on:
  schedule:
    - cron: "0 * * * *"   # every hour (UTC). Change if you want.
  workflow_dispatch:

jobs:
  ping:
    runs-on: ubuntu-latest
    env:
      BASE_URL: ${{ vars.BASE_URL }}
      CRON_SECRET: ${{ secrets.CRON_SECRET }}
      KV_REST_API_URL: ${{ secrets.KV_REST_API_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN }}
      # --- tuning knobs ---
      ACTIVE_DAYS: "7"       # consider a Prikkr active if touched within N days
      ACTIVE_STATUSES: "collecting,open,active"  # comma-separated allowed statuses
    steps:
      - name: Discover ACTIVE meta:* keys via KV REST and call refresh (with jitter)
        shell: bash
        run: |
          set -euo pipefail

          rand_sleep() {
            # sleep between $1 and $2 milliseconds (default 100..500)
            local min_ms=${1:-100}
            local max_ms=${2:-500}
            local span=$(( max_ms - min_ms ))
            local r=$(( RANDOM % (span+1) + min_ms ))
            # convert ms to seconds with 3 decimals
            python3 - <<PY
import time
time.sleep(${r}/1000.0)
PY
          }

          # -------- initial jitter so all repos don't thundering-herd at :00 --------
          # sleep 5..35 seconds
          initial=$(( RANDOM % 31 + 5 ))
          echo "Initial jitter: sleeping ${initial}s..."
          sleep "${initial}s"

          cursor=0
          keys=()

          # -------- SCAN: find all meta:* keys (supports Vercel KV + Upstash) --------
          while : ; do
            if [[ "$KV_REST_API_URL" == *"upstash.io"* ]]; then
              # Upstash shape
              RESP=$(curl -fsS \
                -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                "$KV_REST_API_URL/scan/${cursor}?match=meta:*&count=200")
              new_cursor=$(echo "$RESP" | jq -r '.result[0]')
              page_keys=$(echo "$RESP" | jq -r '.result[1][]?' || true)
            else
              # Vercel KV shape
              RESP=$(curl -fsS \
                -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                "$KV_REST_API_URL/scan?cursor=${cursor}&match=meta:*&count=200")
              new_cursor=$(echo "$RESP" | jq -r '.cursor // .Cursor // "0"')
              page_keys=$(echo "$RESP" | jq -r '.keys[]?' || true)
            fi

            while IFS= read -r k; do
              [[ -n "$k" ]] && keys+=("$k")
            done <<< "$page_keys"

            [[ -z "$new_cursor" || "$new_cursor" == "0" || "$new_cursor" == "null" ]] && break
            cursor="$new_cursor"
          done

          echo "Found ${#keys[@]} meta:* keys"

          # -------- helper: fetch meta JSON by key (handles both REST shapes) --------
          get_meta_json() {
            local key="$1"
            local RESP
            if [[ "$KV_REST_API_URL" == *"upstash.io"* ]]; then
              RESP=$(curl -fsS -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                "$KV_REST_API_URL/get/${key}")
              # Upstash returns {"result":"<string or json>"}
              echo "$RESP" | jq -r '.result' 2>/dev/null
            else
              # Try Vercel KV common shapes
              if RESP=$(curl -fsS -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                    "$KV_REST_API_URL/get/${key}" 2>/dev/null); then
                :
              else
                # Fallback older shape: /get?key=...
                RESP=$(curl -fsS -H "Authorization: Bearer $KV_REST_API_TOKEN" \
                    "$KV_REST_API_URL/get?key=${key}")
              fi
              # Vercel KV returns {"result": "..."} or {"value": "..."} depending on version
              echo "$RESP" | jq -r '.result // .value' 2>/dev/null
            fi
          }

          # -------- filter: keep only ACTIVE prikkrs --------
          active_ids=()
          now_epoch=$(date -u +%s)
          limit_days="${ACTIVE_DAYS}"
          limit_secs=$(( limit_days * 86400 ))

          # Build allowed status regex from comma list (collecting|open|active)
          allowed_statuses=$(echo "$ACTIVE_STATUSES" | sed 's/,/|/g')

          for key in "${keys[@]}"; do
            meta_raw=$(get_meta_json "$key" || true)
            [[ -z "$meta_raw" || "$meta_raw" == "null" ]] && continue

            # meta_raw is typically a JSON string; ensure it's JSON (if already JSON, this is a no-op)
            if ! meta=$(echo "$meta_raw" | jq -er '. | try (type=="string")' 2>/dev/null); then
              meta_json="$meta_raw"
            else
              # decode JSON string into object
              meta_json=$(echo "$meta_raw" | jq -r 'try fromjson catch empty')
              if [[ -z "$meta_json" ]]; then
                # last resort: treat raw as json already
                meta_json="$meta_raw"
              fi
            fi

            # pull fields we care about
            status=$(echo "$meta_json" | jq -r '.status // .phase // empty')
            lastTouched=$(echo "$meta_json" | jq -r '.lastViewedAt // .updatedAt // .createdAt // empty')
            rangeTo=$(echo "$meta_json" | jq -r '.range.to // empty')

            # status filter
            if [[ -n "$status" ]]; then
              if ! echo "$status" | grep -Eiq "^(${allowed_statuses})$"; then
                # e.g. "closed", "finalized", "archived" -> skip
                continue
              fi
            fi

            # recency filter
            ts="${lastTouched}"
            if [[ -z "$ts" ]]; then
              # if we don't have timestamps, keep it to be safe
              is_recent=1
            else
              if ts_epoch=$(date -u -d "$ts" +%s 2>/dev/null); then
                age=$(( now_epoch - ts_epoch ))
                is_recent=$(( age <= limit_secs ? 1 : 0 ))
              else
                # unparseable -> keep
                is_recent=1
              fi
            fi
            [[ "$is_recent" -eq 0 ]] && continue

            # optional: if date range already ended long ago, skip
            if [[ -n "$rangeTo" ]]; then
              if to_epoch=$(date -u -d "$rangeTo" +%s 2>/dev/null); then
                # keep if ends within 30 days in the past
                if (( now_epoch - to_epoch > 30*86400 )); then
                  continue
                fi
              fi
            fi

            # passed filters → collect id
            id="${key#meta:}"
            active_ids+=("$id")
          done

          # Nothing to do?
          if [[ ${#active_ids[@]} -eq 0 ]]; then
            echo "No ACTIVE Prikkrs. Exiting."
            exit 0
          fi

          echo "Active IDs before shuffle: ${#active_ids[@]}"

          # shuffle to avoid spiky patterns
          mapfile -t active_ids < <(printf "%s\n" "${active_ids[@]}" | shuf)
          echo "Active IDs after shuffle: ${#active_ids[@]}"

          # loop with per-call jitter
          for id in "${active_ids[@]}"; do
            url="$BASE_URL/api/cron/refresh/$CRON_SECRET?id=$id"
            echo "GET $url"
            curl -fsS "$url" >/dev/null && echo " ok" || echo " (failed)"
            # small random delay 120–420ms
            rand_sleep 120 420
          done
